import java.lang.System;
import java.io.*;
import java.util.Stack;
import java_cup.runtime.Symbol;

%%
%class Lexer
%implements java_cup.runtime.Scanner
%function next_token
%type java_cup.runtime.Symbol
%char
%line

%state OpenBracket


%{
	//initialize  variables to be used by class

	class bracketController {
		boolean curly = false;
		boolean bracket = false;
		public bracketController(boolean curly, boolean bracket) {
			this.curly = curly;
			this.bracket = bracket;
		}
	}

	int curlyBrackets = 0;
	int regularBrackets = 0;

	Stack<bracketController> bracketsStack = new Stack<bracketController>();


%}


%init{

//Add code to be executed on initialization of the lexer

%init}


newline = (\n)
unicode_letter = [a-zA-Z]
unicode_char = [^\n\`\"]
commentChars = (.)
letter = [{unicode_letter}"_"]
decimal_digit = [0-9]
keywords = "break"|"default"|"func"|"case"|"struct"|"else"|"package"|"switch"|"const"|"if"|"range"|"type"|"continue"|"for"|"import"|"return"|"var"
binary_op = {OR_OP} | {ADD_OP} |  {REL_OP} | {AND_OP} | {mul_op}
OR_OP = "||"
AND_OP = "&&"
AMBERSAND = "&"
REL_OP =  "=="|"<"|"!="|"<="|">"|">="
EXCLAMATION = "!"
ADD_OP = "+"|"-"|"|"
mul_op = "*"|"/"|{PERCENT}|{SHIFT_LEFT}|{SHIFT_RIGHT}|"&"
SHIFT_LEFT = "<<"
SHIFT_RIGHT = ">>"
INT_LIT = ({decimal_digit})+ | ([1-9]{decimal_digit}*)
escaped_char = \\("a"|"b"|"f"|"n"|"r"|"t"|"v"|\\|\'|\")
PERCENT = "%"
unicode_value = {escaped_char}|{unicode_char}|
raw_string_lit =  \`({unicode_char}+|{newline}+)\`
interpreted_string_lit = (\")({unicode_value})*(\")
STRING_LIT =  {interpreted_string_lit}|{raw_string_lit}
comment = //{commentChars}+
COLON_EQUAL = ":="
CONST = "const"
Import = "import"
FUNC = "func"
CDOTS = "..."
ELSE = "else"
IF = "if"
RETURN = "return"
Comma = ","
PLUS = "+"
EQUAL = "="
SEMI_COLON = ";"
OPEN_PARAN = "("
CLOSE_PARAN = ")"
OPEN_CURLY = "{"
CLOSE_CURLY = "}"
DOT = "."
VAR = "var"
SLASH = "/"
escapeChars = " "
IDENTIFIER =   ({unicode_letter})+({decimal_digit})*({unicode_letter})*
PACKAGE = "package"
ASTRISK = "*"
MINUS = "-"
COLON = ":"
OPEN_SQUARE = "["
CLOSE_SQUARE = "]"
FOR = "for"
INCREMENT = "++"
CASE = "case"
SWITCH = "switch"
DEFAULT = "default"
TAB = "	"
TYPE = "type"
STRUCT = "struct"
LESS_DASH = "<-"


%eofval{
//Add code to be executed when the end of the file is reached
	if(bracketsStack.isEmpty())
	{
		return (new Symbol(sym.EOF,"Done"));
	}
	if(bracketsStack.peek().bracket){
		return (new Symbol(sym.EOF,"There is some ( that is not closed"));
	}
	else {
		return (new Symbol(sym.EOF,"There is some { that is not closed"));
	}

%eofval}


%%

<YYINITIAL> {newline} {}
<YYINITIAL> {TYPE} { return (new Symbol(sym.TYPE,yytext()));}
<YYINITIAL> {STRUCT} { return (new Symbol(sym.STRUCT,yytext()));}
<YYINITIAL> {escapeChars} {}
<YYINITIAL> {TAB} {}
<YYINITIAL> {OPEN_PARAN} {
	bracketController temp = new bracketController(false,true);
	bracketsStack.push(temp);
	regularBrackets++;
	return (new Symbol(sym.OPEN_PARAN,yytext()));
}
<YYINITIAL> {CLOSE_PARAN} {
	if(bracketsStack.isEmpty()){
		return (new Symbol(sym.error,"Error: ) has no matching ( in line " + (yyline+1)));
	}
	else {

		if(bracketsStack.peek().bracket){
			bracketsStack.pop();
			regularBrackets--;
			return (new Symbol(sym.CLOSE_PARAN,yytext()));
		}
		else {

		if(regularBrackets >= 1){
			//	I know that this bracket was open somewhere
			return (new Symbol(sym.error,"You have a missing bracket in line " + (yyline+1)));
		}
			return (new Symbol(sym.error,") has no matching ( in line " + (yyline+1)));
		}
	}
}
<YYINITIAL> {OPEN_CURLY} {
	bracketController temp = new bracketController(true,false);
	bracketsStack.push(temp);
	 curlyBrackets++;
	 return (new Symbol(sym.OPEN_CURLY,yytext()));
}
<YYINITIAL> {CLOSE_CURLY} {
	if(bracketsStack.isEmpty()){
		return (new Symbol(sym.error,"Error: } has no matching { in line " + (yyline+1)));
	}
	else {
		if(bracketsStack.peek().curly){
			bracketsStack.pop();
			curlyBrackets--;
			return (new Symbol(sym.CLOSE_CURLY,yytext()));
		}
		else {
				if(curlyBrackets >= 1){
					//	I know that this bracket was open somewhere
					return (new Symbol(sym.error,"You have a missing bracket in line " + (yyline+1)));
				}
			return (new Symbol(sym.error,"} has no matching { in line " + (yyline+1)));
		}
	}
}

<YYINITIAL> {CDOTS} { return (new Symbol(sym.CDOTS,yytext()));}
<YYINITIAL> {LESS_DASH} { return (new Symbol(sym.LESS_DASH,yytext()));}
<YYINITIAL> {EXCLAMATION} { return (new Symbol(sym.EXCLAMATION,yytext()));}
<YYINITIAL> {PERCENT} { return (new Symbol(sym.PERCENT,yytext()));}
<YYINITIAL> {DOT} { return (new Symbol(sym.DOT,yytext()));}
<YYINITIAL> {CONST} { return (new Symbol(sym.CONST,yytext()));}
<YYINITIAL> {PACKAGE} { return (new Symbol(sym.PACKAGE,yytext()));}
<YYINITIAL> {AMBERSAND} { return (new Symbol(sym.AMBERSAND,yytext()));}
<YYINITIAL> {Import} { return (new Symbol(sym.IMPORT,yytext()));}
<YYINITIAL> {FUNC} { return (new Symbol(sym.FUNC,yytext()));}
<YYINITIAL> {ELSE} { return (new Symbol(sym.ELSE,yytext()));}
<YYINITIAL> {IF} { return (new Symbol(sym.IF,yytext()));}
<YYINITIAL> {RETURN} { return (new Symbol(sym.RETURN,yytext()));}
<YYINITIAL> {ASTRISK} { return (new Symbol(sym.ASTRISK,yytext()));}
<YYINITIAL> {MINUS} { return (new Symbol(sym.MINUS,yytext()));}
<YYINITIAL> {FOR} { return (new Symbol(sym.FOR,yytext()));}
<YYINITIAL> {INCREMENT} { return (new Symbol(sym.INCREMENT,yytext()));}
<YYINITIAL> {CASE} { return (new Symbol(sym.CASE,yytext()));}
<YYINITIAL> {SWITCH} { return (new Symbol(sym.SWITCH,yytext()));}
<YYINITIAL> {DEFAULT} { return (new Symbol(sym.DEFAULT,yytext()));}
<YYINITIAL> {VAR} { return (new Symbol(sym.VAR,yytext()));}
<YYINITIAL> {REL_OP} { return (new Symbol(sym.REL_OP,yytext()));}
<YYINITIAL> {PLUS} { return (new Symbol(sym.PLUS,yytext()));}
<YYINITIAL> {EQUAL} { return (new Symbol(sym.EQUAL,yytext()));}
<YYINITIAL> {COLON} { return (new Symbol(sym.COLON,yytext()));}
<YYINITIAL> {OPEN_SQUARE} { return (new Symbol(sym.OPEN_SQUARE,yytext()));}
<YYINITIAL> {CLOSE_SQUARE} { return (new Symbol(sym.CLOSE_SQUARE,yytext()));}
<YYINITIAL> {COLON_EQUAL} { return (new Symbol(sym.COLON_EQUAL,yytext()));}
<YYINITIAL> {AND_OP} { return (new Symbol(sym.AND_OP,yytext()));}
<YYINITIAL> {OR_OP} { return (new Symbol(sym.OR_OP,yytext()));}
<YYINITIAL> {STRING_LIT} { return (new Symbol(sym.STRING_LIT,yytext()));}
<YYINITIAL> {Comma} { return (new Symbol(sym.COMMA,yytext()));}
<YYINITIAL> {IDENTIFIER} { return (new Symbol(sym.IDENTIFIER,yytext()));}
<YYINITIAL> {INT_LIT} { return (new Symbol(sym.INT_LIT,yytext()));}
<YYINITIAL> {SLASH} { return (new Symbol(sym.SLASH,yytext()));}
<YYINITIAL> {SEMI_COLON} { return (new Symbol(sym.SEMI_COLON,yytext()));}
<YYINITIAL> {comment} {}



<YYINITIAL> . {
  return new Symbol(sym.error, "Invalid input: " + yytext() + " in line " + (yyline+1)) ;
}
